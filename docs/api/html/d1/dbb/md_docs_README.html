<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SyterKit: SyterKit Intro</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../SyterKit LOGO_SMALL.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SyterKit
   &#160;<span id="projectnumber">0.2.6</span>
   </div>
   <div id="projectbrief">SyterKit is a bare-metal framework designed for Allwinner platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SyterKit Intro </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><img src="https://github.com/YuzukiHD/SyterKit/assets/12003087/e6135860-1a6a-4cb4-b0f6-71af8eca1509" alt="SyterKit LOGO_Thin" class="inline"/></p>
<p>SyterKit is a bare-metal framework designed for Allwinner platform. SyterKit utilizes CMake as its build system and supports various applications and peripheral drivers. Additionally, SyterKit also has bootloader functionality, which enables it to replace U-Boot for fast booting (standard Linux 6.7 mainline boot time of 1.02s, significantly faster than traditional U-Boot's 3s boot time).</p>
<h1><a class="anchor" id="autotoc_md54"></a>
Support list</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Board   </th><th class="markdownTableHeadNone">Manufacturer   </th><th class="markdownTableHeadNone">Platform   </th><th class="markdownTableHeadNone">Spec   </th><th class="markdownTableHeadNone">Details   </th><th class="markdownTableHeadNone">Config    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/YuzukiHD/Yuzukilizard">Yuzukilizard</a>   </td><td class="markdownTableBodyNone">YuzukiHD   </td><td class="markdownTableBodyNone">V851s   </td><td class="markdownTableBodyNone">Cortex A7   </td><td class="markdownTableBodyNone"><a href="../../board/yuzukilizard">board/yuzukilizard</a>   </td><td class="markdownTableBodyNone"><code>yuzukilizard.cmake</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/YuzukiHD/TinyVision">TinyVision</a>   </td><td class="markdownTableBodyNone">YuzukiHD   </td><td class="markdownTableBodyNone">V851se   </td><td class="markdownTableBodyNone">Cortex A7   </td><td class="markdownTableBodyNone"><a href="../../board/tinyvision">board/tinyvision</a>   </td><td class="markdownTableBodyNone"><code>tinyvision.cmake</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100ask-t113s3   </td><td class="markdownTableBodyNone">100ask   </td><td class="markdownTableBodyNone">T113-S3   </td><td class="markdownTableBodyNone">Dual-Core Cortex A7   </td><td class="markdownTableBodyNone"><a href="../../board/100ask-t113s3">board/100ask-t113s3</a>   </td><td class="markdownTableBodyNone"><code>100ask-t113s3.cmake</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100ask-t113i   </td><td class="markdownTableBodyNone">100ask   </td><td class="markdownTableBodyNone">T113-I   </td><td class="markdownTableBodyNone">Dual-Core Cortex A7 + C906 RISC-V   </td><td class="markdownTableBodyNone"><a href="../../board/100ask-t113i">board/100ask-t113i</a>   </td><td class="markdownTableBodyNone"><code>100ask-t113i.cmake</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100ask-d1-h   </td><td class="markdownTableBodyNone">100ask   </td><td class="markdownTableBodyNone">D1-H   </td><td class="markdownTableBodyNone">C906 RISC-V   </td><td class="markdownTableBodyNone"><a href="../../board/100ask-d1-h">board/100ask-d1-h</a>   </td><td class="markdownTableBodyNone"><code>100ask-d1-h.cmake</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dongshanpi-aict   </td><td class="markdownTableBodyNone">100ask   </td><td class="markdownTableBodyNone">V853   </td><td class="markdownTableBodyNone">Cortex A7   </td><td class="markdownTableBodyNone"><a href="../../board/dongshanpi-aict">board/dongshanpi-aict</a>   </td><td class="markdownTableBodyNone"><code>dongshanpi-aict.cmake</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">project-yosemite   </td><td class="markdownTableBodyNone">YuzukiHD   </td><td class="markdownTableBodyNone">V853   </td><td class="markdownTableBodyNone">Cortex A7   </td><td class="markdownTableBodyNone"><a href="../../board/project-yosemite">board/project-yosemite</a>   </td><td class="markdownTableBodyNone"><code>project-yosemite.cmake</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100ask ROS   </td><td class="markdownTableBodyNone">100ask   </td><td class="markdownTableBodyNone">R818   </td><td class="markdownTableBodyNone">Quad-Core Cortex A53   </td><td class="markdownTableBodyNone"><a href="../../board/100ask-ros">board/100ask-ros</a>   </td><td class="markdownTableBodyNone"><code>100ask-ros.cmake</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://wiki.sipeed.com/hardware/zh/longan/H618/lpi3h/1_intro.html">longanpi-3h</a>   </td><td class="markdownTableBodyNone">sipeed   </td><td class="markdownTableBodyNone">H618   </td><td class="markdownTableBodyNone">Quad-Core Cortex A53   </td><td class="markdownTableBodyNone"><a href="../../board/longanpi-3h">board/longanpi-3h</a>   </td><td class="markdownTableBodyNone"><code>longanpi-3h.cmake</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">longanpi-4b   </td><td class="markdownTableBodyNone">sipeed   </td><td class="markdownTableBodyNone">T527   </td><td class="markdownTableBodyNone">Octa-Core Cortex A55   </td><td class="markdownTableBodyNone"><a href="../../board/longanpi-4b">board/longanpi-4b</a>   </td><td class="markdownTableBodyNone"><code>longanpi-4b.cmake</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://www.myir.cn/shows/134/70.html">LT527X</a>   </td><td class="markdownTableBodyNone">myir-tech   </td><td class="markdownTableBodyNone">T527   </td><td class="markdownTableBodyNone">Octa-Core Cortex A55   </td><td class="markdownTableBodyNone"><a href="../../board/lt527x">board/lt527x</a>   </td><td class="markdownTableBodyNone"><code>lt527x.cmake</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BingPi-M1   </td><td class="markdownTableBodyNone">BingPi   </td><td class="markdownTableBodyNone">V3s   </td><td class="markdownTableBodyNone">Cortex A7   </td><td class="markdownTableBodyNone"><a href="../../board/bingpi-m1">board/bingpi-m1</a>   </td><td class="markdownTableBodyNone"><code>bingpi-m1.cmake</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md55"></a>
Getting Started</h1>
<h2><a class="anchor" id="autotoc_md56"></a>
Building SyterKit From Scratch</h2>
<p>Building SyterKit is a straightforward process that only requires setting up the environment for compilation on a Linux operating system. The software packages required by SyterKit include:</p>
<ul>
<li><code>gcc-arm-none-eabi</code></li>
<li><code>CMake</code></li>
</ul>
<p>For commonly used Ubuntu systems, they can be installed using the following command:</p>
<div class="fragment"><div class="line">sudo apt-get update</div>
<div class="line">sudo apt-get install gcc-arm-none-eabi cmake build-essential -y</div>
</div><!-- fragment --><p>Then create a folder to store the compiled output files and navigate to it:</p>
<div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
</div><!-- fragment --><p>Finally, run the following commands to compile SyterKit:</p>
<div class="fragment"><div class="line">cmake -DCMAKE_BOARD_FILE={Board_config_file.cmake} ..</div>
<div class="line">make</div>
</div><!-- fragment --><p>For example, if you want to compile SyterKit for the TinyVision platform, you need the following command:</p>
<div class="fragment"><div class="line">cmake -DCMAKE_BOARD_FILE=tinyvision.cmake ..</div>
<div class="line">make</div>
</div><!-- fragment --><p>The compiled executable files will be located in <code>build/board/{board_name}/{app_name}</code>.</p>
<p>The SyterKit project will compile two versions: firmware ending with <code>.elf</code> is for USB booting and requires bootloading by PC-side software, while firmware ending with <code>.bin</code> is for flashing and can be written into storage devices such as TF cards and SPI NAND.</p>
<ul>
<li>For SD Card, You need to flash the <code>xxx_card.bin</code></li>
<li>For SPI NAND/SPI NOR, You need to flash the <code>xxx_spi.bin</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md57"></a>
Creating TF Card Boot Firmware</h2>
<p>After build the firmware, you can flash it into the TF card. For the V851s platform, you can write it to either an 8K offset or a 128K offset. Generally, if the TF card uses MBR format, write it with an 8K offset. If it uses GPT format, write it with a 128K offset. Assuming <code>/dev/sdb</code> is the target TF card, you can use the following command to write it with an 8K offset:</p>
<div class="fragment"><div class="line">sudo dd if=syter_boot_bin_card.bin of=/dev/sdb bs=1024 seek=8</div>
</div><!-- fragment --><p>If it is a GPT partition table, you need to write it with a 128K offset:</p>
<div class="fragment"><div class="line">sudo dd if=syter_boot_bin_card.bin of=/dev/sdb bs=1024 seek=128</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md58"></a>
Creating the Firmware for SPI NAND</h3>
<p>For SPI NAND, we need to create the firmware for SPI NAND by writing SyterKit to the corresponding positions:</p>
<div class="fragment"><div class="line">dd if=syter_boot_bin_spi.bin of=spi.img bs=2k</div>
<div class="line">dd if=syter_boot_bin_spi.bin of=spi.img bs=2k seek=32</div>
<div class="line">dd if=syter_boot_bin_spi.bin of=spi.img bs=2k seek=64</div>
</div><!-- fragment --><p>You can also include the Linux kernel and device tree in the firmware:</p>
<div class="fragment"><div class="line">dd if=sunxi.dtb of=spi.img bs=2k seek=128     # DTB on page 128</div>
<div class="line">dd if=zImage of=spi.img bs=2k seek=256        # Kernel on page 256</div>
</div><!-- fragment --><p>Use the xfel tool to flash the created firmware into SPI NAND:</p>
<div class="fragment"><div class="line">xfel spinand write 0x0 spi.img</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md59"></a>
Creating the Firmware for SPI NOR</h3>
<p>For SPI NOR, we need to create the firmware for SPI NOR by writing SyterKit to the corresponding positions:</p>
<div class="fragment"><div class="line">dd if=syter_boot_bin_spi.bin of=spi.img bs=2k</div>
<div class="line">dd if=syter_boot_bin_spi.bin of=spi.img bs=2k seek=32</div>
<div class="line">dd if=syter_boot_bin_spi.bin of=spi.img bs=2k seek=64</div>
</div><!-- fragment --><p>You can also include the Linux kernel and device tree in the firmware:</p>
<div class="fragment"><div class="line">dd if=sunxi.dtb of=spi.img bs=2k seek=128     # DTB on page 128</div>
<div class="line">dd if=zImage of=spi.img bs=2k seek=256        # Kernel on page 256</div>
</div><!-- fragment --><p>Use the xfel tool to flash the created firmware into SPI NOR:</p>
<div class="fragment"><div class="line">xfel spinor write 0x0 spi.img</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md60"></a>
Development</h1>
<h2><a class="anchor" id="autotoc_md61"></a>
How &lt;tt&gt;HELL&lt;/tt&gt; the device boot up</h2>
<p>The device boot as noted over several places, BROM is the first step in booting and is baked into chip itself. Moving from the BROM, Allwinner boots something called boot0 from a storage device such as TF Card, SPI NAND, SPI NOR and so on. The magicvalue for the AllWinner bootloader in various places is 'eGON' and thus the bootloader shall be known as such. The chip will read the valided code from storage device to SRAM and execute the code in SRAM, the load lenth and start address in SRAM are defined in <code><a class="el" href="../../d4/d73/structboot__file__head.html">boot_file_head</a></code>.</p>
<h3><a class="anchor" id="autotoc_md62"></a>
Boot Head</h3>
<h4><a class="anchor" id="autotoc_md63"></a>
boot_file_head</h4>
<p>The define of <code><a class="el" href="../../d4/d73/structboot__file__head.html">boot_file_head</a></code> used to detect as follow:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d73/structboot__file__head.html">boot_file_head</a> {</div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a> <a class="code" href="../../d4/d73/structboot__file__head.html#a816af1d00fe1d5aca3a8f64c909015be">jump_instruction</a>; <span class="comment">/* one intruction jumping to real code */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#af7aa217d9ae1abca94f93e4052ee9689">uint8_t</a> <a class="code" href="../../d4/d73/structboot__file__head.html#a1b3ded80302881b0be8c32202cbf1be4">magic</a>[8];          <span class="comment">/* =&quot;eGON.BT0&quot; */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a> <a class="code" href="../../d4/d73/structboot__file__head.html#a0ea5874d6cbc98d09e0fb3dd95fa11a1">check_sum</a>;        <span class="comment">/* generated by PC */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a> *<a class="code" href="../../d4/d73/structboot__file__head.html#a479852988482e6ef4d4d912307a8967a">length</a>;          <span class="comment">/* generated by LD */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a> <a class="code" href="../../d4/d73/structboot__file__head.html#a355241ec7d479cee657e342ed2943275">pub_head_size</a>;    <span class="comment">/* the size of boot_file_head_t */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#af7aa217d9ae1abca94f93e4052ee9689">uint8_t</a> <a class="code" href="../../d4/d73/structboot__file__head.html#a6298e83ec27e5a74122cb0678564387c">pub_head_vsn</a>[4];   <span class="comment">/* the version of boot_file_head_t */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a> *<a class="code" href="../../d4/d73/structboot__file__head.html#a3ac9c6a35f440ea333d462204dc3e5e0">ret_addr</a>;        <span class="comment">/* the return value */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a> *<a class="code" href="../../d4/d73/structboot__file__head.html#a04e2ab41a4a77f7e07753b55c75a9629">run_addr</a>;        <span class="comment">/* run addr */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a> <a class="code" href="../../d4/d73/structboot__file__head.html#a61098fce012c694fe852aca9aa1fde38">boot_cpu</a>;         <span class="comment">/* eGON version */</span></div>
<div class="line">    <a class="code" href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#af7aa217d9ae1abca94f93e4052ee9689">uint8_t</a> <a class="code" href="../../d4/d73/structboot__file__head.html#a55f1759a33dbad28a513288ffec965fc">platform</a>[8];       <span class="comment">/* platform information */</span></div>
<div class="line">} <a class="code" href="../../d7/dea/100ask-d1-h_2head_8c.html#a1021124e85fea27401d5bdd511383846">boot_file_head_t</a>;</div>
<div class="ttc" id="a100ask-d1-h_2head_8c_html_a1021124e85fea27401d5bdd511383846"><div class="ttname"><a href="../../d7/dea/100ask-d1-h_2head_8c.html#a1021124e85fea27401d5bdd511383846">boot_file_head_t</a></div><div class="ttdeci">struct boot_file_head boot_file_head_t</div></div>
<div class="ttc" id="aboard_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h_html_a80a9c870f4d95f081766ab33e8f001ee"><div class="ttname"><a href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#a80a9c870f4d95f081766ab33e8f001ee">uint32_t</a></div><div class="ttdeci">u32_t uint32_t</div><div class="ttdef"><b>Definition:</b> stdint.h:13</div></div>
<div class="ttc" id="aboard_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h_html_af7aa217d9ae1abca94f93e4052ee9689"><div class="ttname"><a href="../../d2/d3e/board_2100ask-t113i_2load__c906_2c906__firmware_2include_2stdint_8h.html#af7aa217d9ae1abca94f93e4052ee9689">uint8_t</a></div><div class="ttdeci">u8_t uint8_t</div><div class="ttdef"><b>Definition:</b> stdint.h:7</div></div>
<div class="ttc" id="astructboot__file__head_html"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html">boot_file_head</a></div><div class="ttdef"><b>Definition:</b> head.c:6</div></div>
<div class="ttc" id="astructboot__file__head_html_a04e2ab41a4a77f7e07753b55c75a9629"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a04e2ab41a4a77f7e07753b55c75a9629">boot_file_head::run_addr</a></div><div class="ttdeci">uint32_t * run_addr</div><div class="ttdef"><b>Definition:</b> head.c:14</div></div>
<div class="ttc" id="astructboot__file__head_html_a0ea5874d6cbc98d09e0fb3dd95fa11a1"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a0ea5874d6cbc98d09e0fb3dd95fa11a1">boot_file_head::check_sum</a></div><div class="ttdeci">uint32_t check_sum</div><div class="ttdef"><b>Definition:</b> head.c:9</div></div>
<div class="ttc" id="astructboot__file__head_html_a1b3ded80302881b0be8c32202cbf1be4"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a1b3ded80302881b0be8c32202cbf1be4">boot_file_head::magic</a></div><div class="ttdeci">uint8_t magic[8]</div><div class="ttdef"><b>Definition:</b> head.c:8</div></div>
<div class="ttc" id="astructboot__file__head_html_a355241ec7d479cee657e342ed2943275"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a355241ec7d479cee657e342ed2943275">boot_file_head::pub_head_size</a></div><div class="ttdeci">uint32_t pub_head_size</div><div class="ttdef"><b>Definition:</b> head.c:11</div></div>
<div class="ttc" id="astructboot__file__head_html_a3ac9c6a35f440ea333d462204dc3e5e0"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a3ac9c6a35f440ea333d462204dc3e5e0">boot_file_head::ret_addr</a></div><div class="ttdeci">uint32_t * ret_addr</div><div class="ttdef"><b>Definition:</b> head.c:13</div></div>
<div class="ttc" id="astructboot__file__head_html_a479852988482e6ef4d4d912307a8967a"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a479852988482e6ef4d4d912307a8967a">boot_file_head::length</a></div><div class="ttdeci">uint32_t * length</div><div class="ttdef"><b>Definition:</b> head.c:10</div></div>
<div class="ttc" id="astructboot__file__head_html_a55f1759a33dbad28a513288ffec965fc"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a55f1759a33dbad28a513288ffec965fc">boot_file_head::platform</a></div><div class="ttdeci">uint8_t platform[8]</div><div class="ttdef"><b>Definition:</b> head.c:16</div></div>
<div class="ttc" id="astructboot__file__head_html_a61098fce012c694fe852aca9aa1fde38"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a61098fce012c694fe852aca9aa1fde38">boot_file_head::boot_cpu</a></div><div class="ttdeci">uint32_t boot_cpu</div><div class="ttdef"><b>Definition:</b> head.c:15</div></div>
<div class="ttc" id="astructboot__file__head_html_a6298e83ec27e5a74122cb0678564387c"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a6298e83ec27e5a74122cb0678564387c">boot_file_head::pub_head_vsn</a></div><div class="ttdeci">uint8_t pub_head_vsn[4]</div><div class="ttdef"><b>Definition:</b> head.c:12</div></div>
<div class="ttc" id="astructboot__file__head_html_a816af1d00fe1d5aca3a8f64c909015be"><div class="ttname"><a href="../../d4/d73/structboot__file__head.html#a816af1d00fe1d5aca3a8f64c909015be">boot_file_head::jump_instruction</a></div><div class="ttdeci">uint32_t jump_instruction</div><div class="ttdef"><b>Definition:</b> head.c:7</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md64"></a>
disassemble of boot_file_head</h4>
<p>If you disassemble a compiled SyterKit binary, you will find that the head of the program is not the startup code but a startup header. This startup header is used by BROM to identify the size and length of the code that needs to be started and to verify it.</p>
<p>Here is a disassembly part of helloworld_bin, we focous on the <a class="el" href="../../d4/d73/structboot__file__head.html">boot_file_head</a> part:</p>
<div class="fragment"><div class="line">helloworld_bin:     file format elf32-littlearm</div>
<div class="line">Disassembly of section .text:</div>
<div class="line"> </div>
<div class="line">00044000 &lt;boot_head&gt;:</div>
<div class="line">   44000:   ea00000e    b   44040 &lt;_start&gt; # jump_instruction, jump to the actrucl code 0x44040</div>
<div class="line">   44004:   4e4f4765                       # magic &#39;e&#39; &#39;G&#39; &#39;O&#39; &#39;N&#39;</div>
<div class="line">   44008:   3054422e                       # magic &#39;.&#39; &#39;B&#39; &#39;T&#39; &#39;0&#39;</div>
<div class="line">   4400c:   12345678                       # check sum, need reset after padding, now use 0x12345678 to hold the place</div>
<div class="line">   44010:   0000c0c8                       # length of the code</div>
<div class="line">   44014:   00000030                       # the size of boot_file_head_t</div>
<div class="line">   44018:   30303033                       # the version of boot_file_head_t</div>
<div class="line">   4401c:   00044000                       # the return value, not used in SyterKit, set same as start address</div>
<div class="line">   44020:   00044000                       # start address</div>
<div class="line">   44024:   00000000                       # eGON version, set to 0x0</div>
<div class="line">   44028:   2e330000                       # platform 0 0 &#39;3&#39; &#39;.&#39;</div>
<div class="line">   4402c:   00302e30                       # platform &#39;0&#39; &#39;.&#39; &#39;0&#39; 0</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">00044040 &lt;_start&gt;:</div>
<div class="line">   44040:   ea000014    b   44098 &lt;reset&gt;  # the actrucl start code</div>
<div class="line">   44044:   e320f000    nop {0}</div>
<div class="line">   44048:   e320f000    nop {0}</div>
<div class="line">   4404c:   e320f000    nop {0}</div>
<div class="line">   44050:   e320f000    nop {0}</div>
<div class="line">   44054:   e320f000    nop {0}</div>
<div class="line">   44058:   e320f000    nop {0}</div>
<div class="line">   4405c:   e320f000    nop {0}</div>
<div class="line">    ...</div>
<div class="line">    ...</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>From the above, it is known that the first instruction at the program entry point is a jump instruction, which skips the boot_head to execute the actual startup code. BROM then performs verification of SyterKit by reading boot_head and retrieves the corresponding code to the corresponding address.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
eGON.BT0</h3>
<p>In SyterKit supported platform, The BROM will seek the <code>eGON.BT0</code> magic from device storage.</p>
<h4><a class="anchor" id="autotoc_md66"></a>
MMC Device</h4>
<p>For the MMC Device, Such as TF Card, SD NAND, eMMC, UFS, the mapping as follows:</p>
<div class="fragment"><div class="line">+--------+----------+------------------------------+</div>
<div class="line">| 0K--8K |              8K----END                  |</div>
<div class="line">+--------+----------+------------------------------+</div>
<div class="line">|  MBR   | SyterKit |         Other Code           |</div>
<div class="line">+--------+----------+------------------------------+</div>
</div><!-- fragment --><p>But for the GPT partition table, Due to 8K can't fit the GPT partition table and backup table, the chip support to check the header in 128K</p>
<div class="fragment"><div class="line">+----------+-----------------------------------------+</div>
<div class="line">| 0K--128K |             128K----END                 |</div>
<div class="line">+----------+-----------------------------------------+</div>
<div class="line">|   GPT    | SyterKit |         Other Code           |</div>
<div class="line">+----------+----------+------------------------------+</div>
</div><!-- fragment --><p>The 8KB offset is dictated by the BROM, it will check for a valid eGON header at this location. if no valid eGON signature is found at 8KB, BROM can also check the header from sector 256 (128KB) of an SD card or eMMC.</p>
<h4><a class="anchor" id="autotoc_md67"></a>
MTD Device</h4>
<p>For the MTD Device, Such as SPI NAND, SPI NOR, the mapping as follows:</p>
<div class="fragment"><div class="line">+--------------------------------------------------+</div>
<div class="line">|                   0K------END                    |</div>
<div class="line">+-------------------+------------------------------+</div>
<div class="line">|     SyterKit      |         Other Code           |</div>
<div class="line">+-------------------+------------------------------+</div>
</div><!-- fragment --><p>MTD Device is sample, check a valid eGON header and weeeeeee it run!</p>
<h4><a class="anchor" id="autotoc_md68"></a>
RAW Device</h4>
<p>SyterKit does not Support NFTL Raw NAND.</p>
<h4><a class="anchor" id="autotoc_md69"></a>
About the jump_instruction for ARM</h4>
<p>The jump_instruction field stores a jump instruction: (B BACK_OF_boot_file_head_address). When this jump instruction is executed, the program will jump to the first instruction after the <a class="el" href="../../d4/d73/structboot__file__head.html">boot_file_head</a>.</p>
<p>The B instruction encoding in ARM instructions is as follows:</p>
<div class="fragment"><div class="line">+--------+---------+------------------------------+</div>
<div class="line">| 31--28 | 27--24  |            23--0             |</div>
<div class="line">+--------+---------+------------------------------+</div>
<div class="line">|  cond  | 1 0 1 0 |        signed_immed_24       |</div>
<div class="line">+--------+---------+------------------------------+</div>
</div><!-- fragment --><p>The "ARM Architecture Reference Manual" explains this instruction as follows:</p>
<div class="fragment"><div class="line">Syntax:</div>
<div class="line">B{&lt;cond&gt;}  &lt;target_address&gt;</div>
<div class="line">  &lt;cond&gt;    Is the condition under which the instruction is executed. If the</div>
<div class="line">            &lt;cond&gt; is omitted, the AL (always, its code is 0b1110) is used.</div>
<div class="line">  &lt;target_address&gt;</div>
<div class="line">            Specifies the address to branch to. The branch target address is</div>
<div class="line">            calculated by:</div>
<div class="line">            1.  Sign-extending the 24-bit signed (two&#39;s complement) immediate</div>
<div class="line">                to 32 bits.</div>
<div class="line">            2.  Shifting the result left two bits.</div>
<div class="line">            3.  Adding to the contents of the PC, which contains the address</div>
<div class="line">                of the branch instruction plus 8.</div>
</div><!-- fragment --><p>Based on this explanation, the highest 8 bits of the instruction encoding are: 0b11101010, and the lower 24 bits are generated dynamically based on the size of <a class="el" href="../../d4/d73/structboot__file__head.html">boot_file_head</a>. Therefore, the assembly process of the instruction is as follows:</p>
<div class="fragment"><div class="line">((((((<span class="keyword">sizeof</span>(<a class="code" href="../../d7/dea/100ask-d1-h_2head_8c.html#a1021124e85fea27401d5bdd511383846">boot_file_head_t</a>) + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) + 1)) &amp; 0x00FFFFFF) | 0xEA000000)</div>
<div class="line"> </div>
<div class="line">((<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d73/structboot__file__head.html">boot_file_head_t</a>) + <span class="keyword">sizeof</span>(int)) / <span class="keyword">sizeof</span>(int))                                       -&gt; Obtain the number of <span class="stringliteral">&quot;words&quot;</span> occupied by the file header</div>
<div class="line">(((<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d73/structboot__file__head.html">boot_file_head_t</a>) + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) + 1)                                 -&gt; Set the offset to the real start code</div>
<div class="line">(((((<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d73/structboot__file__head.html">boot_file_head_t</a>) + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) + 1)) &amp; 0x00FFFFFF)                -&gt; Obtain the <span class="keywordtype">signed</span>-immed-24</div>
<div class="line">((((((<span class="keyword">sizeof</span>(<a class="code" href="../../d7/dea/100ask-d1-h_2head_8c.html#a1021124e85fea27401d5bdd511383846">boot_file_head_t</a>) + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) + 1)) &amp; 0x00FFFFFF) | 0xEA000000) -&gt; Assemble into a B instruction</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md70"></a>
About the jump_instruction for RISC-V</h4>
<p>The jump_instruction field stores a jump instruction: (J BACK_OF_boot_file_head). When this jump instruction is executed, the program will jump to the first instruction after the <a class="el" href="../../d4/d73/structboot__file__head.html">boot_file_head</a>.</p>
<p>The Unconditional Jumps instruction encoding in RISC-V instructions is as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BROM_FILE_HEAD_SIZE (sizeof(boot_file_head_t) &amp; 0x00FFFFF)</span></div>
<div class="line"><span class="preprocessor">#define BROM_FILE_HEAD_BIT_10_1 ((BROM_FILE_HEAD_SIZE &amp; 0x7FE) &gt;&gt; 1)</span></div>
<div class="line"><span class="preprocessor">#define BROM_FILE_HEAD_BIT_11 ((BROM_FILE_HEAD_SIZE &amp; 0x800) &gt;&gt; 11)</span></div>
<div class="line"><span class="preprocessor">#define BROM_FILE_HEAD_BIT_19_12 ((BROM_FILE_HEAD_SIZE &amp; 0xFF000) &gt;&gt; 12)</span></div>
<div class="line"><span class="preprocessor">#define BROM_FILE_HEAD_BIT_20 ((BROM_FILE_HEAD_SIZE &amp; 0x100000) &gt;&gt; 20)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define BROM_FILE_HEAD_SIZE_OFFSET ((BROM_FILE_HEAD_BIT_20 &lt;&lt; 31) |   \</span></div>
<div class="line"><span class="preprocessor">                                    (BROM_FILE_HEAD_BIT_10_1 &lt;&lt; 21) | \</span></div>
<div class="line"><span class="preprocessor">                                    (BROM_FILE_HEAD_BIT_11 &lt;&lt; 20) |   \</span></div>
<div class="line"><span class="preprocessor">                                    (BROM_FILE_HEAD_BIT_19_12 &lt;&lt; 12))</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define JUMP_INSTRUCTION (BROM_FILE_HEAD_SIZE_OFFSET | 0x6f)</span></div>
</div><!-- fragment --><p>This code appears to be a series of preprocessor macro definitions that manipulate the value of <code>BROM_FILE_HEAD_SIZE</code> to derive different bit positions and create a final constant <code>JUMP_INSTRUCTION</code>.</p>
<p>Unconditional Jumps</p>
<blockquote class="doxtable">
<p>The jump and link (JAL) instruction uses the J-type format, where the J-immediate encodes a signed offset in multiples of 2 bytes. The offset is sign-extended and added to the pc to form the jump target address. Jumps can therefore target a ±1 MiB range. JAL stores the address of the instruction following the jump (pc+4) into register rd. The standard software calling convention uses x1 as the return address register and x5 as an alternate link register. </p>
</blockquote>
<p>Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd=x0. we use it here.</p>
<p>The Plain unconditional jumps instruction in the RV (RISC-V) instruction set is a type of instruction that allows for unconditional branching in the program flow. It is represented by the assembler pseudo-op J. This instruction is used to unconditionally change the program's control flow and jump to a specified target address.</p>
<p>The encoding of the J instruction in the RV instruction set is as follows: </p><div class="fragment"><div class="line">+------------------------------------------------+</div>
<div class="line">|        imm[20]   |   imm[10:1]   |  imm[11]    |</div>
<div class="line">+------------------------------------------------+</div>
<div class="line">|      jump_offset[19:12]   |  rd (destination)  |</div>
<div class="line">+------------------------------------------------+</div>
<div class="line">|  opcode (6 bits) |   imm[19:12]   |     rd     |</div>
<div class="line">+------------------------------------------------+</div>
</div><!-- fragment --><p>The J instruction takes a 20-bit signed immediate value and a target register (rd) as operands, where the target register stores the return address after the jump. The calculation of the target address for the jump is as follows:</p>
<ol type="1">
<li>Sign-extend the 20-bit immediate value to 32 bits.</li>
<li>Left-shift the immediate value by one bit (multiply by 2) to align it with the instruction boundary. The RV instruction set has a fixed instruction length of 4 bytes (32 bits), so the target address needs to be left-shifted by 1 bit for alignment.</li>
<li>Clear the lower bits of the PC register (current instruction address + 4) to align it with the instruction boundary.</li>
<li>Add the aligned PC address and the left-shifted immediate value to obtain the final jump target address.</li>
</ol>
<p>Therefore, the J instruction in the RV instruction set is used for implementing unconditional jumps, allowing the program flow to be redirected to a specified target address, thereby altering the program's execution path.</p>
<p>Here's a brief description of each macro:</p><ol type="1">
<li><code>BROM_FILE_HEAD_SIZE</code>: Calculates the size of <code>boot0_file_head_t</code> and masks it with <code>0x00FFFFF</code>.</li>
<li><code>BROM_FILE_HEAD_BIT_10_1</code>: Extracts specific bits from <code>BROM_FILE_HEAD_SIZE</code> and shifts them.</li>
<li><code>BROM_FILE_HEAD_BIT_11</code>: Extracts a specific bit from <code>BROM_FILE_HEAD_SIZE</code>.</li>
<li><code>BROM_FILE_HEAD_BIT_19_12</code>: Extracts specific bits from <code>BROM_FILE_HEAD_SIZE</code> and shifts them.</li>
<li><code>BROM_FILE_HEAD_BIT_20</code>: Extracts a specific bit from <code>BROM_FILE_HEAD_SIZE</code>.</li>
<li><code>BROM_FILE_HEAD_SIZE_OFFSET</code>: Combines the extracted bits from previous macros to form a final offset value.</li>
<li><code>JUMP_INSTRUCTION</code>: Creates a jump instruction using the calculated <code>BROM_FILE_HEAD_SIZE_OFFSET</code> and a constant value <code>0x6f</code> means <code>j #offset</code> which is <code>jal x0 #offset</code> in RV asm.</li>
</ol>
<h4><a class="anchor" id="autotoc_md71"></a>
About the check_sum and length</h4>
<p>In the block device, need to padding the binary file, and that will need to reset the checksum and length, we provide a tool <code><a class="el" href="../../d4/d42/mksunxi_8c.html">mksunxi.c</a></code> to adjusting bootloader files by correcting header information and ensuring correct formatting.</p>
<p>Specific operations include:</p><ol type="1">
<li>Reading command-line arguments, such as the bootloader file name and padding size.</li>
<li>Opening the bootloader file and obtaining its size.</li>
<li>Ensuring that the file size is greater than the size of the bootloader header.</li>
<li>Allocating memory and reading the contents of the bootloader file into memory.</li>
<li>Calculating the length of the bootloader and aligning it based on the padding size.</li>
<li>Computing the checksum and updating the checksum field in the header information.</li>
<li>Writing the corrected bootloader back to the file.</li>
<li>Displaying information about the corrected bootloader header and the bootloader size.</li>
</ol>
<p>You can find this tool in <code><a class="el" href="../../d4/d42/mksunxi_8c.html">tools/mksunxi.c</a></code> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
